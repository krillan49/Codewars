#===============================================================================================================
#                                               Description
#===============================================================================================================

# Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with nils.
#
# Examples:
#
# interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
# interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, nil]
# interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
# interleave([]) == []

#===============================================================================================================
#                                               Solution
#===============================================================================================================

def interleave(*a)
  return [] if a == []
  max = a.max_by(&:size).size
  a.map!{|e| e.size < max ? e + [nil] * (max - e.size) : e}
  a[0].zip(*a[1..-1]).flatten
end
