#===============================================================================================================
#                                               Description
#===============================================================================================================

# Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!
#
# Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):
#
# 0-9 Push this number onto the stack.
# + Addition: Pop a and b, then push a+b.
# - Subtraction: Pop a and b, then push b-a.
# * Multiplication: Pop a and b, then push a*b.
# / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
# % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
# ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
# ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
# > Start moving right.
# < Start moving left.
# ^ Start moving up.
# v Start moving down.
# ? Start moving in a random cardinal direction.
# _ Pop a value; move right if value = 0, left otherwise.
# | Pop a value; move down if value = 0, up otherwise.
# " Start string mode: push each character's ASCII value all the way up to the next ".
# : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
# \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
# $ Pop value from the stack and discard it.
# . Pop value and output as an integer.
# , Pop value and output the ASCII character represented by the integer code that is stored in the value.
# # Trampoline: Skip next cell.
# p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
# g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
# @ End program.
#   (i.e. a space) No-op. Does nothing.
# The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.
#
# Here's an example:
#
# >987v>.v
# v456<  :
# >321 ^ _@
# will create the output 123456789.
#
# So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:
#
# "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
# This test case will be added for you.

#===============================================================================================================
#                                               Solution
#===============================================================================================================

class Befunge93
  def initialize(map)
    @map = map
    @stack = []
    @output = ''
    @direction = '>'
    @y, @x = 0, 0
    @skip = false
    @string_mode = false
  end

  def run
    element = nil
    new = nil
    loop do
      element = @map[[@y,@x]]
      return @output if element == '@'
      if @skip; @skip = false
      elsif @string_mode; element == '"' ? @string_mode = false : @stack << element.ord
      elsif element == '"'; @string_mode = true
      elsif element == '#'; @skip = true
      elsif /[0-9]/ === element; @stack << element.to_i
      elsif element == '>'; @direction = '>'
      elsif element == 'v'; @direction = 'v'
      elsif element == '<'; @direction = '<'
      elsif element == '^'; @direction = '^'
      elsif element == '?'; @direction = %w[> < v ^][rand(4)]
      elsif element == '+'; @stack << @stack.pop(2).sum
      elsif element == '-'; @stack << @stack.pop(2).inject(:-)
      elsif element == '*'; @stack << @stack.pop(2).inject(:*)
      elsif element == '/'; @stack << (@stack[-1] == 0 ? @stack.pop(2).sum * 0 : @stack.pop(2).inject(:/))
      elsif element == '%'; @stack << (@stack[-1] == 0 ? @stack.pop(2).sum * 0 : @stack.pop(2).inject(:%))
      elsif element == '!'; @stack[-1] = (@stack[-1] == 0 ? 1 : 0)
      elsif element == '`'; @stack << (@stack.pop(2).inject(:-) > 0 ? 1 : 0)
      elsif element == '_'; @direction = (@stack.pop == 0 ? '>' : '<')
      elsif element == '|'; @direction = (@stack.pop == 0 ? 'v' : '^')
      elsif element == ':'; @stack << (@stack.empty? ? 0 : @stack[-1])
      elsif element == "\\"; @stack += (@stack.size > 1 ? @stack.pop(2).reverse : [@stack.pop, 0])
      elsif element == '$'; @stack.pop
      elsif element == '.'; @output += @stack.pop.to_s
      elsif element == ','; @output += @stack.pop.chr
      elsif element == 'p'
        @map[[@stack[-1], @stack[-2]]] = @stack[-3].chr
        @stack.pop(3)
      elsif element == 'g'
        new = @map[[@stack[-1], @stack[-2]]].ord
        @stack.pop(2)
        @stack << new
      end
      move
    end
  end

  private

  def move
    case @direction
    when '>'; @x += 1
    when 'v'; @y += 1
    when '<'; @x -= 1
    when '^'; @y -= 1
    end
  end
end

def interpret(code)
  map = code.split("\n").map.with_index{|s,i| s.chars.map.with_index{|e,j| [[i,j], e]}}.flatten(1).to_h
  befunge93 = Befunge93.new(map)
  befunge93.run
end
